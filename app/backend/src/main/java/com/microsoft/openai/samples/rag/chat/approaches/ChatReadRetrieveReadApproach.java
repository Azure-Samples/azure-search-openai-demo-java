package com.microsoft.openai.samples.rag.chat.approaches;

import com.azure.ai.openai.models.*;
import com.azure.core.util.Context;
import com.azure.search.documents.SearchDocument;
import com.azure.search.documents.models.*;
import com.azure.search.documents.util.SearchPagedIterable;
import com.microsoft.openai.samples.rag.approaches.ContentSource;
import com.microsoft.openai.samples.rag.approaches.RAGApproach;
import com.microsoft.openai.samples.rag.approaches.RAGOptions;
import com.microsoft.openai.samples.rag.approaches.RAGResponse;
import com.microsoft.openai.samples.rag.proxy.CognitiveSearchProxy;
import com.microsoft.openai.samples.rag.proxy.OpenAIProxy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.*;

@Component
public class ChatReadRetrieveReadApproach implements RAGApproach<ChatGPTConversation, RAGResponse> {
    private static final Logger logger = LoggerFactory.getLogger(ChatReadRetrieveReadApproach.class);
    private CognitiveSearchProxy cognitiveSearchProxy;
    private OpenAIProxy openAIProxy;

    public ChatReadRetrieveReadApproach(CognitiveSearchProxy cognitiveSearchProxy, OpenAIProxy openAIProxy) {
        this.cognitiveSearchProxy = cognitiveSearchProxy;
        this.openAIProxy = openAIProxy;
    }

    /**
     * @param conversation
     * @param options
     * @return
     */
    @Override
    public RAGResponse run(ChatGPTConversation conversation, RAGOptions options) {

        // STEP 1: Generate an optimized keyword search query based on the chat history and the last question
        var cognitiveSearchQueryPrompt = new CognitiveSearchQueryPrompt(conversation);
        var completionsOptions = buildCompletionsOptions(cognitiveSearchQueryPrompt);

        Completions completionsResults = openAIProxy.getCompletions(completionsOptions);
        String optimizedQuestion = completionsResults.getChoices().get(0).getText();
        logger.info("Keyword search query generated by Open AI [{}]",optimizedQuestion);

        // STEP 2: Retrieve relevant documents from the search index with the GPT optimized query
        SearchPagedIterable searchResults = getCognitiveSearchResults(optimizedQuestion, options);

        List<ContentSource> sources = buildSourcesFromSearchResults(options, searchResults);
        logger.info("Total %s sources found in cognitive search for keyword search query[%s]".formatted(sources.size(),optimizedQuestion));

        // Replace whole prompt is not supported yet
        var semanticSearchChat= new SemanticSearchChat(conversation, sources,options.getPromptTemplate(),false,options.isSuggestFollowupQuestions());
        var chatCompletionsOptions = buildChatCompletionsOptions(semanticSearchChat);

        // STEP 3: Generate a contextual and content specific answer using the search results and chat history
        ChatCompletions chatCompletions = openAIProxy.getChatCompletions(chatCompletionsOptions);

        logger.debug("Chat completion generated with Prompt Tokens[{}], Completions Tokens[{}], Total Tokens[{}]",
                chatCompletions.getUsage().getPromptTokens(),
                chatCompletions.getUsage().getCompletionTokens(),
                chatCompletions.getUsage().getTotalTokens());

        return new RAGResponse.Builder()
                .question(optimizedQuestion)
                .prompt(formatChat(semanticSearchChat))
                .answer(chatCompletions.getChoices().get(0).getMessage().getContent())
                .sources(sources)
                .build();


    }

    private String formatChat(SemanticSearchChat semanticSearchChat) {
        StringBuilder sb = new StringBuilder();
        semanticSearchChat.getMessages().forEach(message -> {
            if(message.getRole() == ChatRole.USER){
                sb.append("<|im_start|>user\n");
            } else if(message.getRole() == ChatRole.ASSISTANT) {
                sb.append("<|im_start|>assistant\n");
            } else {
                sb.append("<|im_start|>system\n");
            }
            sb.append(message.getContent()).append("\n").append("|im_end|").append("\n");
        });
        return sb.toString();
    }

    private CompletionsOptions buildCompletionsOptions(CognitiveSearchQueryPrompt retrieveThenReadPrompt) {
        CompletionsOptions completionsOptions = new CompletionsOptions(new ArrayList<>( Arrays.asList(retrieveThenReadPrompt.getFormattedPrompt())));

        // Due to a potential bug in using JVM 17 and java open SDK 1.0.0-beta.2, we need to provide default for all properties to avoid 404 bad Request on the server
        completionsOptions.setMaxTokens(1024);
        completionsOptions.setTemperature(0.3);
        completionsOptions.setStop(new ArrayList<>( Arrays.asList("<|im_end|>","<|im_start|>")));
        completionsOptions.setLogitBias(new HashMap<>());
        completionsOptions.setEcho(false);
        completionsOptions.setN(1);
        completionsOptions.setStream(false);
        completionsOptions.setUser( "search-openai-demo-java");
        completionsOptions.setPresencePenalty(0.0);
        completionsOptions.setFrequencyPenalty(0.0);
        completionsOptions.setBestOf(1);

        return completionsOptions;
    }

    private ChatCompletionsOptions buildChatCompletionsOptions(SemanticSearchChat semanticSearchChat) {
        ChatCompletionsOptions completionsOptions = new ChatCompletionsOptions(semanticSearchChat.getMessages());

        // Due to a potential bug in using JVM 17 and java open SDK 1.0.0-beta.2, we need to provide default for all properties to avoid 404 bad Request on the server
        completionsOptions.setMaxTokens(1024);
        completionsOptions.setTemperature(0.3);
        completionsOptions.setStop(new ArrayList<>( Arrays.asList("\n")));
        completionsOptions.setLogitBias(new HashMap<>());
        completionsOptions.setN(1);
        completionsOptions.setStream(false);
        completionsOptions.setUser( "search-openai-demo-java");
        completionsOptions.setPresencePenalty(0.0);
        completionsOptions.setFrequencyPenalty(0.0);


        return completionsOptions;
    }

    private SearchPagedIterable getCognitiveSearchResults(String question, RAGOptions options) {
        var searchOptions = new SearchOptions();

        Optional.ofNullable(options.getTop()).ifPresentOrElse(
                value -> searchOptions.setTop(value),
                () -> searchOptions.setTop(3));
        Optional.ofNullable(options.getExcludeCategory())
                .ifPresentOrElse(
                        value -> searchOptions.setFilter("category ne '%s'".formatted(value.replace("'", "''"))),
                        () -> searchOptions.setFilter(null));

        Optional.ofNullable(options.isSemanticRanker()).ifPresent(isSemanticRanker -> {
            if(isSemanticRanker) {
                searchOptions.setQueryType(QueryType.SEMANTIC);
                searchOptions.setQueryLanguage(QueryLanguage.EN_US);
                searchOptions.setSpeller(QuerySpellerType.LEXICON);
                searchOptions.setSemanticConfigurationName("default");
                searchOptions.setQueryCaption(QueryCaptionType.EXTRACTIVE);
                searchOptions.setQueryCaptionHighlightEnabled(false);
            }
        });

        SearchPagedIterable searchResults = this.cognitiveSearchProxy.search(question, searchOptions, Context.NONE);
        return searchResults;
    }

    private List<ContentSource> buildSourcesFromSearchResults(RAGOptions options, SearchPagedIterable searchResults) {
        List<ContentSource> sources = new ArrayList<ContentSource>();

        searchResults.iterator().forEachRemaining(result ->
        {
            var searchDocument = result.getDocument(SearchDocument.class);

            /**
             If captions is enabled the content source is taken from the captions generated by the semantic ranker.
             Captions are appended sequentially and separated by a dot.
             */
            if(options.isSemanticCaptions()) {
                StringBuffer sourcesContentBuffer = new StringBuffer();

                result.getCaptions().forEach(caption -> {
                    sourcesContentBuffer.append(caption.getText()).append(".");
                });

                sources.add(new ContentSource((String)searchDocument.get("sourcepage"), sourcesContentBuffer.toString()));
            } else {
                //If captions is disabled the content source is taken from the cognitive search index field "content"
                sources.add(new ContentSource((String) searchDocument.get("sourcepage"), (String) searchDocument.get("content")));
            }
        });
        return sources;
    }
}
