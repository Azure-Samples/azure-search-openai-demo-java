package com.microsoft.openai.samples.rag.ask.approaches.semantickernel;

import com.azure.core.util.Context;
import com.azure.search.documents.SearchDocument;
import com.azure.search.documents.models.SearchOptions;
import com.azure.search.documents.util.SearchPagedIterable;
import com.microsoft.openai.samples.rag.approaches.RAGOptions;
import com.microsoft.openai.samples.rag.proxy.CognitiveSearchProxy;
import com.microsoft.semantickernel.skilldefinition.annotations.DefineSKFunction;
import com.microsoft.semantickernel.skilldefinition.annotations.SKFunctionInputAttribute;
import com.microsoft.semantickernel.skilldefinition.annotations.SKFunctionParameters;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import reactor.core.publisher.Mono;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;


public class CognitiveSearchPlugin {
    private static final Logger logger = LoggerFactory.getLogger(CognitiveSearchPlugin.class);
    private CognitiveSearchProxy cognitiveSearchProxy;
    private SearchOptions searchOptions;

    private RAGOptions options;

    public CognitiveSearchPlugin(CognitiveSearchProxy cognitiveSearchProxy, SearchOptions searchOptions, RAGOptions options) {
        this.cognitiveSearchProxy = cognitiveSearchProxy;
        this.searchOptions = searchOptions;
        this.options = options;
    }


    @DefineSKFunction(name = "Search", description = "Search information relevant to answering a given query")
    public Mono<String> search(
            @SKFunctionInputAttribute(description = "the query to answer")
            String query
    ) {
        SearchPagedIterable searchResults = this.cognitiveSearchProxy.search(query, this.searchOptions, Context.NONE);

        StringBuffer sourcesText = new StringBuffer();
        AtomicInteger resultsCount = new AtomicInteger(0);

        searchResults.iterator().forEachRemaining(result ->
        {
            var searchDocument = result.getDocument(SearchDocument.class);

            /**
             If captions is enabled the content source is taken from the captions generated by the semantic ranker.
             Captions are appended sequentially and separated by a dot.
             */
            if(options.isSemanticCaptions()) {
                StringBuffer sourcesContentBuffer = new StringBuffer();

                result.getCaptions().forEach(caption -> {
                    sourcesContentBuffer.append(caption.getText()).append(".");
                });

                sourcesText.append((String)searchDocument.get("sourcepage"))
                        .append(": ")
                        .append(sourcesContentBuffer.toString())
                        .append("\n");
            } else {
                //If captions is disabled the content source is taken from the cognitive search index field "content"
                sourcesText.append((String)searchDocument.get("sourcepage"))
                        .append(": ")
                        .append(((String) searchDocument.get("content")).replace("\n", ""))
                        .append("\n");
            }
            resultsCount.getAndIncrement();
        });
        logger.info("Total %s sources found in cognitive search for keyword search query[%s]".formatted(resultsCount,query));

        return Mono.just(sourcesText.toString());

    }

}