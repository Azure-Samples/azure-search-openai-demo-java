package com.microsoft.openai.samples.rag.retrieval;

import com.azure.ai.openai.models.ChatCompletions;
import com.azure.ai.openai.models.Completions;
import com.azure.core.util.Context;
import com.azure.search.documents.SearchDocument;
import com.azure.search.documents.models.*;
import com.azure.search.documents.util.SearchPagedIterable;
import com.microsoft.openai.samples.rag.approaches.ContentSource;
import com.microsoft.openai.samples.rag.approaches.RAGOptions;
import com.microsoft.openai.samples.rag.common.ChatGPTConversation;
import com.microsoft.openai.samples.rag.common.ChatGPTUtils;
import com.microsoft.openai.samples.rag.proxy.CognitiveSearchProxy;
import com.microsoft.openai.samples.rag.proxy.OpenAIProxy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Component
public class CognitiveSearchRetriever implements Retriever{
    private static final Logger LOGGER = LoggerFactory.getLogger(CognitiveSearchRetriever.class);
    private final CognitiveSearchProxy cognitiveSearchProxy;
    private final OpenAIProxy openAIProxy;

    public CognitiveSearchRetriever(CognitiveSearchProxy cognitiveSearchProxy,OpenAIProxy openAIProxy){
        this.cognitiveSearchProxy = cognitiveSearchProxy;
        this.openAIProxy = openAIProxy;
    }
    @Override
    public List<ContentSource> retrieveFromQuestion(String question, RAGOptions ragOptions) {
        SearchPagedIterable searchResults = getCognitiveSearchResults(question, ragOptions);
        return buildSourcesFromSearchResults(ragOptions, searchResults);

    }

    @Override
    public List<ContentSource> retrieveFromConversation(ChatGPTConversation conversation, RAGOptions ragOptions) {

        // STEP 1: Generate an optimized keyword search query based on the chat history and the last question
        var extractKeywordsChatTemplate = new ExtractKeywordsChatTemplate(conversation);
        var chatCompletionsOptions = ChatGPTUtils.buildDefaultChatCompletionsOptions(extractKeywordsChatTemplate.getMessages());
        ChatCompletions chatCompletions = openAIProxy.getChatCompletions(chatCompletionsOptions);

        var searchKeywords = chatCompletions.getChoices().get(0).getMessage().getContent();
        LOGGER.info("Search Keywords extracted by Open AI [{}]",searchKeywords);

        // STEP 2: Retrieve relevant documents from the search index with the GPT optimized search keywords
        SearchPagedIterable searchResults = getCognitiveSearchResults(searchKeywords, ragOptions);
        return buildSourcesFromSearchResults(ragOptions, searchResults);
    }

    private SearchPagedIterable getCognitiveSearchResults(String question, RAGOptions options) {
        return this.cognitiveSearchProxy.search(question, buildSearchOptions(options), Context.NONE);
    }

    private List<ContentSource> buildSourcesFromSearchResults(RAGOptions options, SearchPagedIterable searchResults) {
        List<ContentSource> sources = new ArrayList<>();

        searchResults.iterator().forEachRemaining(result ->
        {
            var searchDocument = result.getDocument(SearchDocument.class);

            /*
             If captions is enabled the content source is taken from the captions generated by the semantic ranker.
             Captions are appended sequentially and separated by a dot.
             */
            if(options.isSemanticCaptions()) {
                StringBuilder sourcesContentBuffer = new StringBuilder();

                result.getCaptions().forEach(caption -> sourcesContentBuffer.append(caption.getText()).append("."));

                sources.add(new ContentSource((String)searchDocument.get("sourcepage"), sourcesContentBuffer.toString()));
            } else {
                //If captions is disabled the content source is taken from the cognitive search index field "content"
                sources.add(new ContentSource((String) searchDocument.get("sourcepage"), (String) searchDocument.get("content")));
            }
        });

        return sources;
    }

    private SearchOptions buildSearchOptions(RAGOptions options) {
        var searchOptions = new SearchOptions();

        Optional.ofNullable(options.getTop()).ifPresentOrElse(
                searchOptions::setTop,
                () -> searchOptions.setTop(3));
        Optional.ofNullable(options.getExcludeCategory())
                .ifPresentOrElse(
                        value -> searchOptions.setFilter("category ne '%s'".formatted(value.replace("'", "''"))),
                        () -> searchOptions.setFilter(null));

        Optional.ofNullable(options.isSemanticRanker()).ifPresent(isSemanticRanker -> {
            if (isSemanticRanker) {
                searchOptions.setQueryType(QueryType.SEMANTIC);
                searchOptions.setQueryLanguage(QueryLanguage.EN_US);
                searchOptions.setSpeller(QuerySpellerType.LEXICON);
                searchOptions.setSemanticConfigurationName("default");
                searchOptions.setQueryCaption(QueryCaptionType.EXTRACTIVE);
                searchOptions.setQueryCaptionHighlightEnabled(false);
            }
        });

        return searchOptions;
    }
}
